1. Fast and Slow Pointer
 - Cycle detection method
 - O(1) space efficiency
 - Linked list problems

2. Merge Intervals
 - Sort and merge
 - O(n log n) complexity
 - Overlapping interval handling

3. Sliding Window
 - Fixed/variable window
 - O(n) time optimization
 - Subarray/substring problems

4. Islands (Matrix Traversal)
 - DFS/BFS traversal
 - Connected component detection
 - 2D grid problems

5. Two Pointers
 - Dual pointer strategy
 - Linear time complexity
 - Array/list problems

6. Cyclic Sort
 - Sorting in cycles
 - O(n) time complexity
 - Constant space usage

7. In-place Reversal of Linked List
 - Reverse without extra space
 - O(n) time efficiency
 - Pointer manipulation technique

8. Breadth First Search
 - Level-by-level traversal
 - Uses queue structure
 - Shortest path problems

9. Depth First Search
 - Recursive/backtracking approach
 - Uses stack (or recursion)
 - Tree/graph traversal

10. Two Heaps
 - Max and min heaps
 - Median tracking efficiently
 - O(log n) insertions

11. Subsets
 - Generate all subsets
 - Recursive or iterative
 - Backtracking or bitmasking

12. Modified Binary Search
 - Search in variations
 - O(log n) time
 - Rotated/specialized arrays

13. Bitwise XOR
 - Toggle bits operation
 - O(1) space complexity
 - Efficient for pairing

14. Top 'K' elements
 - Use heap/quickselect
 - O(n log k) time
 - Efficient selection problem

15. K-way Merge
 - Merge sorted lists
 - Min-heap based approach
 - O(n log k) complexity

16. 0/1 Knapsack (Dynamic Programming)
 - Choose or skip items
 - O(n * W) complexity
 - Maximize value selection

17. Unbounded Knapsack (Dynamic Programming)
 - Unlimited item choices
 - O(n * W) complexity
 - Multiple item selection

18. Topological Sort (Graphs)
 - Directed acyclic graph
 - Order dependency resolution
 - Uses DFS or BFS

19. Monotonic Stack
 - Maintain increasing/decreasing stack
 - Optimized for range queries
 - O(n) time complexity

20. Backtracking
 - Recursive decision-making
 - Explore all possibilities
 - Pruning with constraints
L